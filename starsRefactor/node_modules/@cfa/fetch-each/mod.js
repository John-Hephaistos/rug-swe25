/**
 * Do a single workflow
 */ export const fetchEach = async (/** JSON serializable array */ array, /** Pass a logger to view updates */ config)=>{
  const requestJsons = array.map((item)=>typeof item === "string" ? {
      url: item
    } : item);
  const response = await fetch(config.basePath, {
    method: "POST",
    body: JSON.stringify(requestJsons),
    headers: {
      Authorization: `Bearer ${config.apiKey}`,
      Accept: "text/event-stream"
    }
  });
  if (!response.ok) {
    throw new Error(`fetchEach failed for ${config.basePath}: ${response.status} ${await response.text()}`);
  }
  if (!response.body) {
    throw new Error("No response body");
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let resultBuffer = "";
  let collectingResult = false;
  while(true){
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, {
      stream: true
    });
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    let eventType = undefined;
    for (const line of lines){
      if (line.startsWith("event: ")) {
        eventType = line.slice(7).trim();
        if (eventType === "result" || eventType === "update") {
          collectingResult = true;
          continue;
        }
      }
      if (collectingResult && line.startsWith("data: ")) {
        resultBuffer += line.slice(6);
        try {
          const parsed = JSON.parse(resultBuffer);
          if (eventType === "update") {
            config.log?.(parsed);
            collectingResult = false;
          } else if (eventType === "result") {
            return parsed.array;
          }
        } catch  {
          continue;
        }
      }
    }
  }
  throw new Error("Stream ended without complete result");
};
export { fetchLoop } from "./fetchLoop.js";
//# sourceMappingURL=mod.js.map